const std = @import("std");
const mem = std.mem;
const os = std.os;
const fs = std.fs;
const process = std.process;
const Child = process.Child;
const fmt = std.fmt;
const time = std.time;

const StreamIndex = u32;

// TODO: flags for Container, Codec, PixFmt, Filter

const Container = enum {
    @"3dostr",
    @"3g2",
    @"3gp",
    @"4xm",
    a64,
    aa,
    aac,
    aax,
    ac3,
    ace,
    acm,
    act,
    adf,
    adp,
    ads,
    adts,
    adx,
    aea,
    afc,
    aiff,
    aix,
    alaw,
    alias_pix,
    alp,
    alsa,
    amr,
    amrnb,
    amrwb,
    amv,
    anm,
    apac,
    apc,
    ape,
    apm,
    apng,
    aptx,
    aptx_hd,
    aqtitle,
    argo_asf,
    argo_brp,
    argo_cvg,
    asf,
    asf_o,
    asf_stream,
    ass,
    ast,
    au,
    av1,
    avi,
    avif,
    avm2,
    avr,
    avs,
    avs2,
    avs3,
    bethsoftvid,
    bfi,
    bfstm,
    bin,
    bink,
    binka,
    bit,
    bitpacked,
    bmp_pipe,
    bmv,
    boa,
    bonk,
    brender_pix,
    brstm,
    c93,
    caca,
    caf,
    cavsvideo,
    cdg,
    cdxl,
    chromaprint,
    cine,
    codec2,
    codec2raw,
    concat,
    crc,
    cri_pipe,
    dash,
    data,
    daud,
    dcstr,
    dds_pipe,
    derf,
    dfa,
    dfpwm,
    dhav,
    dirac,
    dnxhd,
    dpx_pipe,
    dsf,
    dsicin,
    dss,
    dts,
    dtshd,
    dv,
    dvbsub,
    dvbtxt,
    dvd,
    dxa,
    ea,
    ea_cdata,
    eac3,
    epaf,
    exr_pipe,
    f32be,
    f32le,
    f4v,
    f64be,
    f64le,
    fbdev,
    ffmetadata,
    fifo,
    fifo_test,
    film_cpk,
    filmstrip,
    fits,
    flac,
    flic,
    flv,
    framecrc,
    framehash,
    framemd5,
    frm,
    fsb,
    fwse,
    g722,
    g723_1,
    g726,
    g726le,
    g729,
    gdv,
    gem_pipe,
    genh,
    gif,
    gif_pipe,
    gsm,
    gxf,
    h261,
    h263,
    h264,
    hash,
    hca,
    hcom,
    hdr_pipe,
    hds,
    hevc,
    hls,
    hnm,
    ico,
    idcin,
    idf,
    iec61883,
    iff,
    ifv,
    ilbc,
    image2,
    image2pipe,
    imf,
    ingenient,
    ipmovie,
    ipod,
    ipu,
    ircam,
    ismv,
    iss,
    iv8,
    ivf,
    ivr,
    j2k_pipe,
    jack,
    jacosub,
    jpeg_pipe,
    jpegls_pipe,
    jpegxl_pipe,
    jv,
    kmsgrab,
    kux,
    kvag,
    laf,
    latm,
    lavfi,
    libcdio,
    libdc1394,
    libgme,
    libopenmpt,
    live_flv,
    lmlm4,
    loas,
    lrc,
    luodat,
    lvf,
    lxf,
    m4v,
    matroska,
    webm,
    mca,
    mcc,
    md5,
    mgsts,
    microdvd,
    mjpeg,
    mjpeg_2000,
    mkvtimestamp_v2,
    mlp,
    mlv,
    mm,
    mmf,
    mods,
    moflex,
    mov,
    m4a,
    mj2,
    mp2,
    mp3,
    mp4,
    mpc,
    mpc8,
    mpeg,
    mpeg1video,
    mpeg2video,
    mpegts,
    mpegtsraw,
    mpegvideo,
    mpjpeg,
    mpl2,
    mpsub,
    msf,
    msnwctcp,
    msp,
    mtaf,
    mtv,
    mulaw,
    musx,
    mv,
    mvi,
    mxf,
    mxf_d10,
    mxf_opatom,
    mxg,
    nc,
    nistsphere,
    nsp,
    nsv,
    null,
    nut,
    nuv,
    obu,
    oga,
    ogg,
    ogv,
    oma,
    openal,
    opengl,
    opus,
    oss,
    paf,
    pam_pipe,
    pbm_pipe,
    pcx_pipe,
    pfm_pipe,
    pgm_pipe,
    pgmyuv_pipe,
    pgx_pipe,
    phm_pipe,
    photocd_pipe,
    pictor_pipe,
    pjs,
    pmp,
    png_pipe,
    pp_bnk,
    ppm_pipe,
    psd_pipe,
    psp,
    psxstr,
    pulse,
    pva,
    pvf,
    qcp,
    qdraw_pipe,
    qoi_pipe,
    r3d,
    rawvideo,
    realtext,
    redspark,
    rka,
    rl2,
    rm,
    roq,
    rpl,
    rsd,
    rso,
    rtp,
    rtp_mpegts,
    rtsp,
    s16be,
    s16le,
    s24be,
    s24le,
    s32be,
    s32le,
    s337m,
    s8,
    sami,
    sap,
    sbc,
    sbg,
    scc,
    scd,
    @"sdl,sdl2",
    sdns,
    sdp,
    sdr2,
    sds,
    sdx,
    segment,
    ser,
    sga,
    sgi_pipe,
    shn,
    siff,
    simbiosis_imx,
    sln,
    smjpeg,
    smk,
    smoothstreaming,
    smush,
    sol,
    sox,
    spdif,
    spx,
    srt,
    stl,
    stream_segment,
    ssegment,
    streamhash,
    subviewer,
    subviewer1,
    sunrast_pipe,
    sup,
    svag,
    svcd,
    svg_pipe,
    svs,
    swf,
    tak,
    tedcaptions,
    tee,
    thp,
    tiertexseq,
    tiff_pipe,
    tmv,
    truehd,
    tta,
    ttml,
    tty,
    txd,
    ty,
    u16be,
    u16le,
    u24be,
    u24le,
    u32be,
    u32le,
    u8,
    uncodedframecrc,
    v210,
    v210x,
    vag,
    vbn_pipe,
    vc1,
    vc1test,
    vcd,
    vidc,
    video4linux2,
    v4l2,
    vividas,
    vivo,
    vmd,
    vob,
    vobsub,
    voc,
    vpk,
    vplayer,
    vqf,
    w64,
    wady,
    wav,
    wavarc,
    wc3movie,
    webm_chunk,
    webm_dash_manifest,
    webp,
    webp_pipe,
    webvtt,
    wsaud,
    wsd,
    wsvqa,
    wtv,
    wv,
    wve,
    x11grab,
    xa,
    xbin,
    xbm_pipe,
    xmd,
    xmv,
    xpm_pipe,
    xv,
    xvag,
    xwd_pipe,
    xwma,
    yop,
    yuv4mpegpipe,

    fn append(container: Container, out: anytype) !void {
        try appendFmt(out, "-f", .{});
        try appendFmt(out, "{s}", .{@tagName(container)});
    }
};

const Codec = enum {
    @"012v",
    @"4xm",
    @"8bps",
    a64_multi,
    a64_multi5,
    aasc,
    agm,
    aic,
    alias_pix,
    amv,
    anm,
    ansi,
    apng,
    arbc,
    argo,
    asv1,
    asv2,
    aura,
    aura2,
    av1,
    avrn,
    avrp,
    avs,
    avs2,
    avs3,
    avui,
    ayuv,
    bethsoftvid,
    bfi,
    binkvideo,
    bintext,
    bitpacked,
    bmp,
    bmv_video,
    brender_pix,
    c93,
    cavs,
    cdgraphics,
    cdtoons,
    cdxl,
    cfhd,
    cinepak,
    clearvideo,
    cljr,
    cllc,
    cmv,
    cpia,
    cri,
    cscd,
    cyuv,
    daala,
    dds,
    dfa,
    dirac,
    dnxhd,
    dpx,
    dsicinvideo,
    dvvideo,
    dxa,
    dxtory,
    dxv,
    escape124,
    escape130,
    exr,
    ffv1,
    ffvhuff,
    fic,
    fits,
    flashsv,
    flashsv2,
    flic,
    flv1,
    fmvc,
    fraps,
    frwu,
    g2m,
    gdv,
    gem,
    gif,
    h261,
    h263,
    h263i,
    h263p,
    h264,
    hap,
    hdr,
    hevc,
    hnm4video,
    hq_hqa,
    hqx,
    huffyuv,
    hymt,
    idcin,
    idf,
    iff_ilbm,
    imm4,
    imm5,
    indeo2,
    indeo3,
    indeo4,
    indeo5,
    interplayvideo,
    ipu,
    jpeg2000,
    jpegls,
    jpegxl,
    jv,
    kgv1,
    kmvc,
    lagarith,
    ljpeg,
    loco,
    lscr,
    m101,
    mad,
    magicyuv,
    mdec,
    media100,
    mimic,
    mjpeg,
    mjpegb,
    mmvideo,
    mobiclip,
    motionpixels,
    mpeg1video,
    mpeg2video,
    mpeg4,
    msa1,
    mscc,
    msmpeg4v1,
    msmpeg4v2,
    msmpeg4v3,
    msp2,
    msrle,
    mss1,
    mss2,
    msvideo1,
    mszh,
    mts2,
    mv30,
    mvc1,
    mvc2,
    mvdv,
    mvha,
    mwsc,
    mxpeg,
    notchlc,
    nuv,
    paf_video,
    pam,
    pbm,
    pcx,
    pfm,
    pgm,
    pgmyuv,
    pgx,
    phm,
    photocd,
    pictor,
    pixlet,
    png,
    ppm,
    prores,
    prosumer,
    psd,
    ptx,
    qdraw,
    qoi,
    qpeg,
    qtrle,
    r10k,
    r210,
    rasc,
    rawvideo,
    rl2,
    roq,
    rpza,
    rscc,
    rv10,
    rv20,
    rv30,
    rv40,
    sanm,
    scpr,
    screenpresso,
    sga,
    sgi,
    sgirle,
    sheervideo,
    simbiosis_imx,
    smackvideo,
    smc,
    smvjpeg,
    snow,
    sp5x,
    speedhq,
    srgc,
    sunrast,
    svg,
    svq1,
    svq3,
    targa,
    targa_y216,
    tdsc,
    tgq,
    tgv,
    theora,
    thp,
    tiertexseqvideo,
    tiff,
    tmv,
    tqi,
    truemotion1,
    truemotion2,
    truemotion2rt,
    tscc,
    tscc2,
    txd,
    ulti,
    utvideo,
    v210,
    v210x,
    v308,
    v408,
    v410,
    vb,
    vble,
    vbn,
    vc1,
    vc1image,
    vcr1,
    vixl,
    vmdvideo,
    vmnc,
    vnull,
    vp3,
    vp4,
    vp5,
    vp6,
    vp6a,
    vp6f,
    vp7,
    vp8,
    vp9,
    vqc,
    vvc,
    wbmp,
    wcmv,
    webp,
    wmv1,
    wmv2,
    wmv3,
    wmv3image,
    wnv1,
    wrapped_avframe,
    ws_vqa,
    xan_wc3,
    xan_wc4,
    xbin,
    xbm,
    xface,
    xpm,
    xwd,
    y41p,
    ylc,
    yop,
    yuv4,
    zerocodec,
    zlib,
    zmbv,
    @"4gv",
    @"8svx_exp",
    @"8svx_fib",
    aac,
    aac_latm,
    ac3,
    @"acelp.kelvin",
    adpcm_4xm,
    adpcm_adx,
    adpcm_afc,
    adpcm_agm,
    adpcm_aica,
    adpcm_argo,
    adpcm_ct,
    adpcm_dtk,
    adpcm_ea,
    adpcm_ea_maxis_xa,
    adpcm_ea_r1,
    adpcm_ea_r2,
    adpcm_ea_r3,
    adpcm_ea_xas,
    adpcm_g722,
    adpcm_g726,
    adpcm_g726le,
    adpcm_ima_acorn,
    adpcm_ima_alp,
    adpcm_ima_amv,
    adpcm_ima_apc,
    adpcm_ima_apm,
    adpcm_ima_cunning,
    adpcm_ima_dat4,
    adpcm_ima_dk3,
    adpcm_ima_dk4,
    adpcm_ima_ea_eacs,
    adpcm_ima_ea_sead,
    adpcm_ima_iss,
    adpcm_ima_moflex,
    adpcm_ima_mtf,
    adpcm_ima_oki,
    adpcm_ima_qt,
    adpcm_ima_rad,
    adpcm_ima_smjpeg,
    adpcm_ima_ssi,
    adpcm_ima_wav,
    adpcm_ima_ws,
    adpcm_ms,
    adpcm_mtaf,
    adpcm_psx,
    adpcm_sbpro_2,
    adpcm_sbpro_3,
    adpcm_sbpro_4,
    adpcm_swf,
    adpcm_thp,
    adpcm_thp_le,
    adpcm_vima,
    adpcm_xa,
    adpcm_xmd,
    adpcm_yamaha,
    adpcm_zork,
    alac,
    amr_nb,
    amr_wb,
    anull,
    apac,
    ape,
    aptx,
    aptx_hd,
    atrac1,
    atrac3,
    atrac3al,
    atrac3p,
    atrac3pal,
    atrac9,
    avc,
    binkaudio_dct,
    binkaudio_rdft,
    bmv_audio,
    bonk,
    cbd2_dpcm,
    celt,
    codec2,
    comfortnoise,
    cook,
    derf_dpcm,
    dfpwm,
    dolby_e,
    dsd_lsbf,
    dsd_lsbf_planar,
    dsd_msbf,
    dsd_msbf_planar,
    dsicinaudio,
    dss_sp,
    dst,
    dts,
    dvaudio,
    eac3,
    evrc,
    fastaudio,
    flac,
    ftr,
    g723_1,
    g729,
    gremlin_dpcm,
    gsm,
    gsm_ms,
    hca,
    hcom,
    iac,
    ilbc,
    imc,
    interplay_dpcm,
    interplayacm,
    mace3,
    mace6,
    metasound,
    misc4,
    mlp,
    mp1,
    mp2,
    mp3,
    mp3adu,
    mp3on4,
    mp4als,
    mpegh_3d_audio,
    msnsiren,
    musepack7,
    musepack8,
    nellymoser,
    opus,
    paf_audio,
    pcm_alaw,
    pcm_bluray,
    pcm_dvd,
    pcm_f16le,
    pcm_f24le,
    pcm_f32be,
    pcm_f32le,
    pcm_f64be,
    pcm_f64le,
    pcm_lxf,
    pcm_mulaw,
    pcm_s16be,
    pcm_s16be_planar,
    pcm_s16le,
    pcm_s16le_planar,
    pcm_s24be,
    pcm_s24daud,
    pcm_s24le,
    pcm_s24le_planar,
    pcm_s32be,
    pcm_s32le,
    pcm_s32le_planar,
    pcm_s64be,
    pcm_s64le,
    pcm_s8,
    pcm_s8_planar,
    pcm_sga,
    pcm_u16be,
    pcm_u16le,
    pcm_u24be,
    pcm_u24le,
    pcm_u32be,
    pcm_u32le,
    pcm_u8,
    pcm_vidc,
    qcelp,
    qdm2,
    qdmc,
    ra_144,
    ra_288,
    ralf,
    rka,
    roq_dpcm,
    s302m,
    sbc,
    sdx2_dpcm,
    shorten,
    sipr,
    siren,
    smackaudio,
    smv,
    sol_dpcm,
    sonic,
    sonicls,
    speex,
    tak,
    truehd,
    truespeech,
    tta,
    twinvq,
    vmdaudio,
    vorbis,
    wady_dpcm,
    wavarc,
    wavesynth,
    wavpack,
    westwood_snd1,
    wmalossless,
    wmapro,
    wmav1,
    wmav2,
    wmavoice,
    xan_dpcm,
    xma1,
    xma2,
    bin_data,
    dvd_nav_packet,
    epg,
    klv,
    mpegts,
    otf,
    scte_35,
    timed_id3,
    ttf,
    arib_caption,
    ass,
    dvb_subtitle,
    dvb_teletext,
    dvd_subtitle,
    eia_608,
    hdmv_pgs_subtitle,
    hdmv_text_subtitle,
    jacosub,
    microdvd,
    mov_text,
    mpl2,
    pjs,
    realtext,
    sami,
    srt,
    ssa,
    stl,
    subrip,
    subviewer,
    subviewer1,
    text,
    ttml,
    vplayer,
    webvtt,
    xsub,

    fn append(codec: Codec, stream: ?StreamIndex, out: anytype) !void {
        if (stream) |s| {
            try appendFmt(out, "-c:{d}", .{s});
        } else {
            try appendFmt(out, "-c", .{});
        }
        try appendFmt(out, "{s}", .{@tagName(codec)});
    }
};

const PixFmt = enum {
    yuv420p,
    yuyv422,
    rgb24,
    bgr24,
    yuv422p,
    yuv444p,
    yuv410p,
    yuv411p,
    gray,
    monow,
    monob,
    pal8,
    yuvj420p,
    yuvj422p,
    yuvj444p,
    uyvy422,
    uyyvyy411,
    bgr8,
    bgr4,
    bgr4_byte,
    rgb8,
    rgb4,
    rgb4_byte,
    nv12,
    nv21,
    argb,
    rgba,
    abgr,
    bgra,
    gray16be,
    gray16le,
    yuv440p,
    yuvj440p,
    yuva420p,
    rgb48be,
    rgb48le,
    rgb565be,
    rgb565le,
    rgb555be,
    rgb555le,
    bgr565be,
    bgr565le,
    bgr555be,
    bgr555le,
    vaapi,
    yuv420p16le,
    yuv420p16be,
    yuv422p16le,
    yuv422p16be,
    yuv444p16le,
    yuv444p16be,
    dxva2_vld,
    rgb444le,
    rgb444be,
    bgr444le,
    bgr444be,
    ya8,
    bgr48be,
    bgr48le,
    yuv420p9be,
    yuv420p9le,
    yuv420p10be,
    yuv420p10le,
    yuv422p10be,
    yuv422p10le,
    yuv444p9be,
    yuv444p9le,
    yuv444p10be,
    yuv444p10le,
    yuv422p9be,
    yuv422p9le,
    gbrp,
    gbrp9be,
    gbrp9le,
    gbrp10be,
    gbrp10le,
    gbrp16be,
    gbrp16le,
    yuva422p,
    yuva444p,
    yuva420p9be,
    yuva420p9le,
    yuva422p9be,
    yuva422p9le,
    yuva444p9be,
    yuva444p9le,
    yuva420p10be,
    yuva420p10le,
    yuva422p10be,
    yuva422p10le,
    yuva444p10be,
    yuva444p10le,
    yuva420p16be,
    yuva420p16le,
    yuva422p16be,
    yuva422p16le,
    yuva444p16be,
    yuva444p16le,
    vdpau,
    xyz12le,
    xyz12be,
    nv16,
    nv20le,
    nv20be,
    rgba64be,
    rgba64le,
    bgra64be,
    bgra64le,
    yvyu422,
    ya16be,
    ya16le,
    gbrap,
    gbrap16be,
    gbrap16le,
    qsv,
    mmal,
    d3d11va_vld,
    cuda,
    @"0rgb",
    rgb0,
    @"0bgr",
    bgr0,
    yuv420p12be,
    yuv420p12le,
    yuv420p14be,
    yuv420p14le,
    yuv422p12be,
    yuv422p12le,
    yuv422p14be,
    yuv422p14le,
    yuv444p12be,
    yuv444p12le,
    yuv444p14be,
    yuv444p14le,
    gbrp12be,
    gbrp12le,
    gbrp14be,
    gbrp14le,
    yuvj411p,
    bayer_bggr8,
    bayer_rggb8,
    bayer_gbrg8,
    bayer_grbg8,
    bayer_bggr16le,
    bayer_bggr16be,
    bayer_rggb16le,
    bayer_rggb16be,
    bayer_gbrg16le,
    bayer_gbrg16be,
    bayer_grbg16le,
    bayer_grbg16be,
    xvmc,
    yuv440p10le,
    yuv440p10be,
    yuv440p12le,
    yuv440p12be,
    ayuv64le,
    ayuv64be,
    videotoolbox_vld,
    p010le,
    p010be,
    gbrap12be,
    gbrap12le,
    gbrap10be,
    gbrap10le,
    mediacodec,
    gray12be,
    gray12le,
    gray10be,
    gray10le,
    p016le,
    p016be,
    d3d11,
    gray9be,
    gray9le,
    gbrpf32be,
    gbrpf32le,
    gbrapf32be,
    gbrapf32le,
    drm_prime,
    opencl,
    gray14be,
    gray14le,
    grayf32be,
    grayf32le,
    yuva422p12be,
    yuva422p12le,
    yuva444p12be,
    yuva444p12le,
    nv24,
    nv42,
    vulkan,
    y210be,
    y210le,
    x2rgb10le,
    x2rgb10be,
    x2bgr10le,
    x2bgr10be,
    p210be,
    p210le,
    p410be,
    p410le,
    p216be,
    p216le,
    p416be,
    p416le,
    vuya,
    rgbaf16be,
    rgbaf16le,
    vuyx,
    p012le,
    p012be,
    y212be,
    y212le,
    xv30be,
    xv30le,
    xv36be,
    xv36le,
    rgbf32be,
    rgbf32le,
    rgbaf32be,
    rgbaf32le,
};

const Filter = enum {
    abench,
    acompressor,
    acontrast,
    acopy,
    acue,
    acrossfade,
    acrossover,
    acrusher,
    adeclick,
    adeclip,
    adecorrelate,
    adelay,
    adenorm,
    aderivative,
    adrc,
    adynamicequalizer,
    adynamicsmooth,
    aecho,
    aemphasis,
    aeval,
    aexciter,
    afade,
    afftdn,
    afftfilt,
    afir,
    aformat,
    afreqshift,
    afwtdn,
    agate,
    aiir,
    aintegral,
    ainterleave,
    alatency,
    alimiter,
    allpass,
    aloop,
    amerge,
    ametadata,
    amix,
    amultiply,
    anequalizer,
    anlmdn,
    anlmf,
    anlms,
    anull,
    apad,
    aperms,
    aphaser,
    aphaseshift,
    apsyclip,
    apulsator,
    arealtime,
    aresample,
    areverse,
    arnndn,
    asdr,
    asegment,
    aselect,
    asendcmd,
    asetnsamples,
    asetpts,
    asetrate,
    asettb,
    ashowinfo,
    asidedata,
    asoftclip,
    aspectralstats,
    asplit,
    asr,
    astats,
    astreamselect,
    asubboost,
    asubcut,
    asupercut,
    asuperpass,
    asuperstop,
    atempo,
    atilt,
    atrim,
    axcorrelate,
    azmq,
    bandpass,
    bandreject,
    bass,
    biquad,
    bs2b,
    channelmap,
    channelsplit,
    chorus,
    compand,
    compensationdelay,
    crossfeed,
    crystalizer,
    dcshift,
    deesser,
    dialoguenhance,
    drmeter,
    dynaudnorm,
    earwax,
    ebur128,
    equalizer,
    extrastereo,
    firequalizer,
    flanger,
    haas,
    hdcd,
    headphone,
    highpass,
    highshelf,
    join,
    ladspa,
    loudnorm,
    lowpass,
    lowshelf,
    lv2,
    mcompand,
    pan,
    replaygain,
    rubberband,
    sidechaincompress,
    sidechaingate,
    silencedetect,
    silenceremove,
    sofalizer,
    speechnorm,
    stereotools,
    stereowiden,
    superequalizer,
    surround,
    tiltshelf,
    treble,
    tremolo,
    vibrato,
    virtualbass,
    volume,
    volumedetect,
    aevalsrc,
    afdelaysrc,
    afirsrc,
    anoisesrc,
    anullsrc,
    flite,
    hilbert,
    sinc,
    sine,
    anullsink,
    addroi,
    alphaextract,
    alphamerge,
    amplify,
    ass,
    atadenoise,
    avgblur,
    avgblur_opencl,
    avgblur_vulkan,
    backgroundkey,
    bbox,
    bench,
    bilateral,
    bilateral_cuda,
    bitplanenoise,
    blackdetect,
    blackframe,
    blend,
    blend_vulkan,
    blockdetect,
    blurdetect,
    bm3d,
    boxblur,
    boxblur_opencl,
    bwdif,
    cas,
    chromaber_vulkan,
    chromahold,
    chromakey,
    chromakey_cuda,
    chromanr,
    chromashift,
    ciescope,
    codecview,
    colorbalance,
    colorchannelmixer,
    colorcontrast,
    colorcorrect,
    colorize,
    colorkey,
    colorkey_opencl,
    colorhold,
    colorlevels,
    colormap,
    colormatrix,
    colorspace,
    colorspace_cuda,
    colortemperature,
    convolution,
    convolution_opencl,
    convolve,
    copy,
    corr,
    cover_rect,
    crop,
    cropdetect,
    cue,
    curves,
    datascope,
    dblur,
    dctdnoiz,
    deband,
    deblock,
    decimate,
    deconvolve,
    dedot,
    deflate,
    deflicker,
    deinterlace_qsv,
    deinterlace_vaapi,
    dejudder,
    delogo,
    denoise_vaapi,
    derain,
    deshake,
    deshake_opencl,
    despill,
    detelecine,
    dilation,
    dilation_opencl,
    displace,
    dnn_classify,
    dnn_detect,
    dnn_processing,
    doubleweave,
    drawbox,
    drawgraph,
    drawgrid,
    drawtext,
    edgedetect,
    elbg,
    entropy,
    epx,
    eq,
    erosion,
    erosion_opencl,
    estdif,
    exposure,
    extractplanes,
    fade,
    feedback,
    fftdnoiz,
    fftfilt,
    field,
    fieldhint,
    fieldmatch,
    fieldorder,
    fillborders,
    find_rect,
    flip_vulkan,
    floodfill,
    format,
    fps,
    framepack,
    framerate,
    framestep,
    freezedetect,
    freezeframes,
    frei0r,
    fspp,
    gblur,
    gblur_vulkan,
    geq,
    gradfun,
    graphmonitor,
    grayworld,
    greyedge,
    guided,
    haldclut,
    hflip,
    hflip_vulkan,
    histeq,
    histogram,
    hqdn3d,
    hqx,
    hstack,
    hsvhold,
    hsvkey,
    hue,
    huesaturation,
    hwdownload,
    hwmap,
    hwupload,
    hwupload_cuda,
    hysteresis,
    identity,
    idet,
    il,
    inflate,
    interlace,
    interleave,
    kerndeint,
    kirsch,
    lagfun,
    latency,
    lenscorrection,
    libplacebo,
    limitdiff,
    limiter,
    loop,
    lumakey,
    lut,
    lut1d,
    lut2,
    lut3d,
    lutrgb,
    lutyuv,
    maskedclamp,
    maskedmax,
    maskedmerge,
    maskedmin,
    maskedthreshold,
    maskfun,
    median,
    mergeplanes,
    mestimate,
    metadata,
    midequalizer,
    minterpolate,
    mix,
    monochrome,
    morpho,
    mpdecimate,
    msad,
    multiply,
    negate,
    nlmeans,
    nlmeans_opencl,
    nnedi,
    noformat,
    noise,
    normalize,
    null,
    oscilloscope,
    overlay,
    overlay_opencl,
    overlay_qsv,
    overlay_vaapi,
    overlay_vulkan,
    overlay_cuda,
    owdenoise,
    pad,
    pad_opencl,
    palettegen,
    paletteuse,
    perms,
    perspective,
    phase,
    photosensitivity,
    pixdesctest,
    pixelize,
    pixscope,
    pp,
    pp7,
    premultiply,
    prewitt,
    prewitt_opencl,
    procamp_vaapi,
    program_opencl,
    pseudocolor,
    psnr,
    pullup,
    qp,
    random,
    readeia608,
    readvitc,
    realtime,
    remap,
    remap_opencl,
    removegrain,
    removelogo,
    repeatfields,
    reverse,
    rgbashift,
    roberts,
    roberts_opencl,
    rotate,
    sab,
    scale,
    scale_cuda,
    scale_qsv,
    scale_vaapi,
    scale_vulkan,
    scale2ref,
    scdet,
    scharr,
    scroll,
    segment,
    select,
    selectivecolor,
    sendcmd,
    separatefields,
    setdar,
    setfield,
    setparams,
    setpts,
    setrange,
    setsar,
    settb,
    sharpness_vaapi,
    shear,
    showinfo,
    showpalette,
    shuffleframes,
    shufflepixels,
    shuffleplanes,
    sidedata,
    signalstats,
    signature,
    siti,
    smartblur,
    sobel,
    sobel_opencl,
    split,
    spp,
    sr,
    ssim,
    ssim360,
    stereo3d,
    streamselect,
    subtitles,
    super2xsai,
    swaprect,
    swapuv,
    tblend,
    telecine,
    thistogram,
    threshold,
    thumbnail,
    thumbnail_cuda,
    tile,
    tinterlace,
    tlut2,
    tmedian,
    tmidequalizer,
    tmix,
    tonemap,
    tonemap_opencl,
    tonemap_vaapi,
    tpad,
    transpose,
    transpose_opencl,
    transpose_vaapi,
    transpose_vulkan,
    trim,
    unpremultiply,
    unsharp,
    unsharp_opencl,
    untile,
    v360,
    vaguedenoiser,
    varblur,
    vectorscope,
    vflip,
    vflip_vulkan,
    vfrdet,
    vibrance,
    vidstabdetect,
    vidstabtransform,
    vif,
    vignette,
    vmafmotion,
    vpp_qsv,
    vstack,
    w3fdif,
    waveform,
    weave,
    xbr,
    xcorrelate,
    xfade,
    xfade_opencl,
    xmedian,
    xstack,
    yadif,
    yadif_cuda,
    yaepblur,
    zmq,
    zoompan,
    zscale,
    hstack_vaapi,
    vstack_vaapi,
    xstack_vaapi,
    hstack_qsv,
    vstack_qsv,
    xstack_qsv,
    allrgb,
    allyuv,
    cellauto,
    color,
    colorchart,
    colorspectrum,
    frei0r_src,
    gradients,
    haldclutsrc,
    life,
    mandelbrot,
    mptestsrc,
    nullsrc,
    openclsrc,
    pal75bars,
    pal100bars,
    rgbtestsrc,
    sierpinski,
    smptebars,
    smptehdbars,
    testsrc,
    testsrc2,
    yuvtestsrc,
    nullsink,
    a3dscope,
    abitscope,
    adrawgraph,
    agraphmonitor,
    ahistogram,
    aphasemeter,
    avectorscope,
    concat,
    showcqt,
    showcwt,
    showfreqs,
    showspatial,
    showspectrum,
    showspectrumpic,
    showvolume,
    showwaves,
    showwavespic,
    spectrumsynth,
    avsynctest,
    amovie,
    movie,
    afifo,
    fifo,
    abuffer,
    buffer,
    abuffersink,
    buffersink,
};

// TODO: parse config well enough

const Config = struct {
    const Version = struct {
        pub fn parseVersion() Version {
            @compileError("TODO");
        }
    };

    encoders: std.EnumSet(Codec),
    decoders: std.EnumSet(Codec),
    pix_fmts: std.EnumSet(PixFmt),
    filters: std.EnumSet(Filter),

    version: Version,
};

// I had to resist the urge to implement per-stream and per-metadata options here. It would get too
// complex.
// TODO MODEL FILTERGRAPHS PROPERLY lmao

/// Measured in nanoseconds.
pub const Duration = struct {
    nsecs: u64,

    /// Units of time.
    const Unit = enum(u64) {
        nanoseconds = 1,
        microseconds = time.ns_per_us,
        milliseconds = time.ns_per_ms,
        seconds = time.ns_per_s,
        minutes = time.ns_per_min,
        hours = time.ns_per_hour,

        pub fn fromByte(c: u8) ?Unit {
            return switch (c) {
                'n' => .nanoseconds,
                'u' => .microseconds,
                'm' => .milliseconds,
                's' => .seconds,
                'M' => .minutes,
                'h' => .hours,
                else => null,
            };
        }
    };

    pub fn formatDecimalTrunc(data: Duration, comptime fmtstr: []const u8, options: fmt.FormatOptions, writer: anytype) !void {
        comptime var rest: []const u8 = undefined;
        const unit = comptime if (fmtstr.len == 0) get_unit: {
            rest = "";
            break :get_unit .seconds;
        } else get_unit: {
            rest = fmtstr[1..];
            break :get_unit Unit.fromByte(fmtstr[0]) orelse {
                rest = fmtstr;
                break :get_unit .seconds;
            };
        };

        try fmt.formatIntValue(data.nsecs / @intFromEnum(unit), rest, options, writer);
    }

    pub fn formatDecimal(data: Duration, comptime fmtstr: []const u8, options: fmt.FormatOptions, writer: anytype) !void {
        comptime var rest: []const u8 = undefined;
        const unit = comptime if (fmtstr.len == 0) get_unit: {
            rest = "";
            break :get_unit .seconds;
        } else get_unit: {
            rest = fmtstr[1..];
            break :get_unit Unit.fromByte(fmtstr[0]) orelse {
                rest = fmtstr;
                break :get_unit .seconds;
            };
        };

        try fmt.formatIntValue(data.nsecs / @intFromEnum(unit), rest, options, writer);
        try writer.writeByte('.');
        try fmt.formatIntValue(data.nsecs % @intFromEnum(unit), rest, options, writer);
    }

    pub fn formatSexagesimal(data: Duration, comptime fmtstr: []const u8, _: fmt.FormatOptions, writer: anytype) !void {
        _ = fmtstr;
        const hms = .{ .alignment = .left, .fill = '0', .width = 2 };
        const us = .{ .alignment = .left, .fill = '0', .width = 3 };

        try fmt.formatIntValue(data.nsecs / time.ns_per_hour, "d", hms, writer);
        try writer.writeByte(':');

        try fmt.formatIntValue(data.nsecs % time.ns_per_hour / time.ns_per_min, "d", hms, writer);
        try writer.writeByte(':');

        try fmt.formatIntValue(data.nsecs % time.ns_per_hour % time.ns_per_min / time.ns_per_s, "d", hms, writer);
        try writer.writeByte('.');

        try fmt.formatIntValue(data.nsecs % time.ns_per_hour % time.ns_per_min % time.ns_per_s / time.ns_per_us, "d", us, writer);
    }

    pub const format = formatSexagesimal;
};

/// An execution of a ffmpeg-style `Binary`. For the options presented, refer to
/// <https://ffmpeg.org/ffmpeg-all.html#Generic-options>.
pub const Exec = struct {
    /// Global options that apply to the entire execution.
    pub const Globals = struct {
        /// Whether to overwrite an output file that exists.
        overwrite_output: bool = false,

        /// Whether to "cast" incompatible media types, like `data`
        recast_media: bool = false,

        fn append(globals: Globals, out: anytype) !void {
            if (globals.overwrite_output) try appendFmt(out, "-y", .{});
            if (globals.recast_media) try appendFmt(out, "-recast_media", .{});
        }
    };

    /// The location where the muxed bitstream is/will be stored.
    pub const Data = union(enum) {
        /// A path to a regular file.
        file_path: []const u8,

        /// A URL. May be anywhere supported by FFmpeg(!), be careful.
        uri: std.Uri,

        /// The same pipe **must not** be specified in one Exec more than once.
        pipe: fs.File,

        fn append(data: Data, out: anytype) !void {
            try switch (data) {
                .pipe => appendFmt(out, "pipe:0", .{}),
                .file_path => |f| appendFmt(out, "file:{s}", .{f}),
                .uri => |u| appendFmt(out, "{}", .{u}),
            };
        }
    };

    /// How to select a pixel format.
    pub const PixFmtOption = union(enum) {
        /// Choose the specified pixel format, or if that isn't possible, the next best one.
        or_best: PixFmt,
        /// Choose the specified pixel format, or if that isn't possible, error.
        forced: PixFmt,
        /// Do not convert the pixel format, or if that isn't possible, error.
        no_conversion: void,

        fn append(pf: PixFmtOption, out: anytype) !void {
            try appendFmt(out, "-pix_fmt", .{});

            try switch (pf) {
                .or_best => |p| appendFmt(out, "{s}", .{@tagName(p)}),
                .forced => |p| appendFmt(out, "+{s}", .{@tagName(p)}),
                .no_conversion => appendFmt(out, "+", .{}),
            };
        }
    };

    /// When to start (de/en)coding.
    pub const StartOption = union(enum) {
        /// At this absolute timestamp.
        timestamp: Duration,
        /// At this timestamp relative to the end of the file.
        timestamp_eof: Duration,

        fn append(so: StartOption, out: anytype) !void {
            switch (so) {
                .timestamp => |ts| {
                    try appendFmt(out, "-ss", .{});
                    try appendFmt(out, "{d}", .{ts});
                },
                .timestamp_eof => |te| {
                    try appendFmt(out, "-sseof", .{});
                    try appendFmt(out, "-{d}", .{te});
                },
            }
        }
    };

    /// When to finish (de/en)coding.
    pub const EndOption = union(enum) {
        /// When this much has been (de/en)coded since the start.
        max_duration: Duration,
        /// At this absolute timestamp.
        timestamp: Duration,

        fn append(eo: EndOption, out: anytype) !void {
            switch (eo) {
                .max_duration => |d| {
                    try appendFmt(out, "-t", .{});
                    try appendFmt(out, "{d}", .{d});
                },
                .timestamp => |t| {
                    try appendFmt(out, "-to", .{});
                    try appendFmt(out, "-{d}", .{t});
                },
            }
        }
    };

    /// An input to FFmpeg. Currently, only supports per-input options, not per-stream options.
    pub const Input = struct {
        data: Data,

        /// The demuxer to demux the data with.
        demuxer: ?Container = null,

        /// The pixel format to decode the data as.
        pix_fmt: ?PixFmtOption = null,

        /// The time at which to begin decoding.
        start: ?StartOption = null,

        /// The time at which to finish decoding.
        end: ?EndOption = null,

        fn append(input: Input, out: anytype) !void {
            if (input.demuxer) |d| {
                try appendFmt(out, "-f", .{});
                try appendFmt(out, "{s}", .{@tagName(d)});
            }

            if (input.pix_fmt) |pf| try pf.append(out);
            if (input.start) |s| try s.append(out);
            if (input.end) |e| try e.append(out);

            try input.data.append(out);
        }
    };

    /// An output of FFmpeg.
    pub const Output = struct {
        data: Data,

        /// The encoder to encode this output's streams with.
        // TODO MAKE THIS A PER-STREAM OPTION AFTER IMPLEMENTING PER-STREAM OPTIONS
        encoder: ?Codec = null,

        /// The muxer to mux this output with.
        muxer: ?Container = null,

        /// The pixel format to assign this output.
        pix_fmt: ?PixFmtOption = null,

        /// A filter graph to apply.
        // FIXME MODEL FILTERGRAPHS!!!
        filter_complex: ?[]const u8 = null,

        /// The time at which to start encoding.
        start: ?StartOption = null,

        /// The time at which to finish encoding.
        end: ?EndOption = null,

        fn append(output: Output, out: anytype) !void {
            if (output.muxer) |d| try d.append(out);

            if (output.pix_fmt) |pf| try pf.append(out);
            if (output.start) |s| try s.append(out);
            if (output.end) |e| try e.append(out);
            if (output.filter_complex) |fc| try appendFmt(out, "{s}", .{fc});

            try output.data.append(out);
        }
    };

    inputs: std.ArrayListUnmanaged(Input) = .{},
    outputs: std.ArrayListUnmanaged(Output) = .{},
    globals: Globals = .{},
    allocator: mem.Allocator,

    pub fn addInput(exec: *Exec, input: Input) mem.Allocator.Error!void {
        return exec.inputs.append(exec.allocator, input);
    }

    pub fn addOutput(exec: *Exec, output: Output) mem.Allocator.Error!void {
        return exec.outputs.append(exec.allocator, output);
    }

    pub fn deinit(exec: *Exec) void {
        exec.inputs.deinit(exec.allocator);
        exec.outputs.deinit(exec.allocator);
        exec.* = undefined;
    }

    pub const ValidateError = error{DuplicatePipe};

    pub fn validate(exec: *const Exec) ValidateError!void {
        var ally_s = std.heap.stackFallback(8 << 10, exec.allocator);
        const ally = ally_s.get();
        var set = std.AutoHashMap(fs.File, void).init(ally);
        defer set.deinit();

        inline for (.{ exec.inputs.items, exec.outputs.items }) |l| {
            for (l) |i| switch (i.data) {
                .pipe => |p| if (try set.fetchPut(p)) |_| return error.DuplicatePipe,
                else => {},
            };
        }
    }

    pub fn buildCmdline(
        exec: *const Exec,
        ally: mem.Allocator,
    ) mem.Allocator.Error![][]u8 {
        var out = std.ArrayList([]u8).init(ally);
        defer out.deinit();
        errdefer for (out.items) |s| ally.free(s);

        try exec.globals.append(&out);
        for (exec.inputs.items) |input| try input.append(&out);
        for (exec.outputs.items) |output| try output.append(&out);

        return try out.toOwnedSlice();
    }

    const RunError = mem.Allocator.Error || Child.SpawnError || ValidateError;

    /// Runs the given `Exec`. On success, it is consumed.
    pub fn run(exec: *Exec) RunError!Process {
        try exec.validate();
        @panic("TODO");
    }
};

pub const Process = struct {
    exec: Exec,
};

const ProbeResult = struct {
    const Stream = struct {};
};

test "cmdline" {
    var exec = Exec{ .allocator = std.testing.allocator };
    defer exec.deinit();
    exec.globals.overwrite_output = true;
    try exec.addInput(.{
        .data = .{ .file_path = "file.txt" },
        .start = .{ .timestamp = .{ .nsecs = 12 * time.ns_per_s } },
    });
    try exec.addOutput(.{ .data = .{ .pipe = std.io.getStdOut() } });
    const s = try exec.buildCmdline(std.testing.allocator);
    std.debug.print("{s}\n", .{s});
    for (s) |x| std.testing.allocator.free(x);
    std.testing.allocator.free(s);
}

// TODO: there's definitely a more elegant solution here
fn appendFmt(al: anytype, comptime format: []const u8, args: anytype) !void {
    const v = try fmt.allocPrint(al.allocator, format, args);
    errdefer al.allocator.free(v);
    try al.append(v);
}
